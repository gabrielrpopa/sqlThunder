/*
 * Copyright 2022-present Infinite Loop Corporation Limited, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.widescope.rdbmsRepo.database.warehouse.repo;



import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException; 
import java.sql.Statement;
import java.util.List;

import com.widescope.logging.AppLogger;
import org.springframework.stereotype.Component;



@Component
public class WarehouseRepoDb {

	// JDBC driver name and database URL 
	private final String JDBC_DRIVER = "org.h2.Driver";   
	private final String DB_URL_DISK = "jdbc:h2:file:./warehouseRepoDb;MODE=PostgreSQL";  
	
	//  Database credentials 
	private final String USER = "sa"; 
	private final String PASS = "sa"; 
	
	public WarehouseRepoDb()	{}
	
		   
	
	private 
	void 
	closeHandles(	Connection conn, 
					Statement statement, 
					ResultSet rs){
		try	{ if(rs !=null && !rs.isClosed()) { rs.close();	} }	catch(Exception ignored)	{}
		try	{ if(statement !=null && !statement.isClosed()) { statement.close();	} }	catch(Exception ignored)	{}
		try	{ if(conn !=null && !conn.isClosed()) { conn.close();	} }	catch(Exception ignored)	{}
	}
	
	

	private 
	void
	createSchema(final List<String> ddlList) throws Exception	{
		Connection conn = null;
		Statement statement = null; 
		try { 
			Class.forName(JDBC_DRIVER);
			conn = DriverManager.getConnection(DB_URL_DISK, USER, PASS);
			statement = conn.createStatement();
			for (String ddl : ddlList) {
				statement.executeUpdate(ddl);
	        }
			
			statement.close();
			conn.commit();
			conn.close();
		} catch (SQLException e)	{
			throw new Exception(AppLogger.logDb(e, Thread.currentThread().getStackTrace()[1]));
		} catch (Exception e) {
			throw new Exception(AppLogger.logException(e, Thread.currentThread().getStackTrace()[1], AppLogger.db));
		} finally	{
			closeHandles(conn, statement, null);
	    } 
	}

	
		

	
	
	public 
	static 
	void generateSchema() throws Exception {
		try {
			List<String> ddlList = new java.util.ArrayList<String>();
			ddlList.add(WarehouseRepoDb.cube);
			ddlList.add(WarehouseRepoDb.cubeIndex1);
			ddlList.add(WarehouseRepoDb.cubeConst1);
			ddlList.add(WarehouseRepoDb.cubeConst2);

			ddlList.add(WarehouseRepoDb.cubeEntitlement);
			ddlList.add(WarehouseRepoDb.cubeEntitlementIndex1);



			WarehouseRepoDb warehouseRepoDb = new WarehouseRepoDb();
			warehouseRepoDb.createSchema(ddlList);
		} catch (SQLException e)	{
			throw new Exception(AppLogger.logDb(e, Thread.currentThread().getStackTrace()[1]));
		} catch (Exception e) {
			throw new Exception(AppLogger.logException(e, Thread.currentThread().getStackTrace()[1], AppLogger.db));
		}


	}
	

	
		
	/*
	 * NOTE: when clusterIdSource is -1 the cubeIdSource > 0 and viceversa. 
	 * When clusterIdSource <= 0 the cubeIdSource > 0 -> the cube is obtained from another cube
	 * When clusterIdSource > 0 the cubeIdSource <= 0 -> the cube is obtained from original 
	 * 
	 * */
	public static String 
	cube = "CREATE TABLE IF NOT EXISTS cube "
			+ " ( cubeId BIGINT  GENERATED BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY,"
				+ "	uniqueName VARCHAR(MAX), "
				+ "	path VARCHAR(MAX), "
				+ "	comment VARCHAR(MAX), "
				/* cubeIdSource: Used to show that this cube comes from another cube, so we can reconcile the source of this cube with destination of another cube*/
				/* cubeIdSource: This can be left -1 but if applies better reflect the source*/
				+ "	cubeIdSource BIGINT DEFAULT -1, "
				+ "	clusterIdSource BIGINT, " /*Source cluster Id where this cube executed against*/
				+ "	clusterTypeSource VARCHAR(MAX) DEFAULT 'RDBMS', "  /*MONGODB/ELASTICSEARCH/RDBMS/EMBEDDED/JSON/CSV/PARQUET*/
				+ "	isCompressedSource VARCHAR(1) DEFAULT 'N', "  /* Y/N */
				+ "	sqlIdSource BIGINT, "  /* reference to SQL/MQL/DQL/STOREDPROC*/
				+ "	clusterIdDest BIGINT, " /*Source cluster Id where this cube executed against*/
				+ "	clusterTypeDest VARCHAR(MAX) DEFAULT 'RDBMS', "  /*MONGODB/ELASTICSEARCH/RDBMS/EMBEDDED/JSON/CSV/PARQUET*/
				+ "	entityDest VARCHAR(MAX), "  /*collection/index/table/file name*/
				+ "	isCompressedDest VARCHAR(1) DEFAULT 'N' "  /* Y/N */
		+ ")";
	
	public static String cubeIndex1 = "CREATE UNIQUE INDEX IF NOT EXISTS idx_subCube_1 ON cube(uniqueName);";
	
	public static String cubeConst1 = "ALTER TABLE cube ADD CONSTRAINT IF NOT EXISTS ck_cube_1  CHECK (clusterTypeSource IN ('MONGODB', 'ELASTICSEARCH', 'RDBMS', 'EMBEDDED', 'JSON', 'CSV', 'PARQUET') );";
	public static String cubeConst2 = "ALTER TABLE cube ADD CONSTRAINT IF NOT EXISTS ck_cube_2  CHECK (isCompressedSource IN ('Y', 'N') );";

	public static String cubeConst3 = "ALTER TABLE cube ADD CONSTRAINT IF NOT EXISTS ck_cube_3  CHECK (clusterTypeDest IN ('MONGODB', 'ELASTICSEARCH', 'RDBMS', 'EMBEDDED', 'JSON', 'CSV', 'PARQUET') );";
	public static String cubeConst4 = "ALTER TABLE cube ADD CONSTRAINT IF NOT EXISTS ck_cube_4  CHECK (isCompressedDest IN ('Y', 'N') );";

	
	
	
	public static String 
	cubeEntitlement = "CREATE TABLE IF NOT EXISTS cubeEntitlement "
			+ " ( entId BIGINT  GENERATED BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY,"
				+ "	cubeId BIGINT, "
				+ "	userId BIGINT "
				
		+ ")";
	
	
	public static String cubeEntitlementIndex1 = "CREATE UNIQUE INDEX IF NOT EXISTS idx_cubeEntitlement ON cubeEntitlement(cubeId, userId);";
	

	

	

	public 
	RepoCubeRecordList 
	getRepoCubeRecordList(final String uniqueName) throws Exception {


		Class.forName(JDBC_DRIVER);
		String sqlString = "SELECT cubeId, "
								+ "uniqueName, "
								+ "path, "
								+ "comment, "
								+ "cubeIdSource, "
								+ "clusterIdSource, "
								+ "clusterTypeSource, "
								+ "isCompressedSource, "
								+ "sqlIdSource, "
								+ "clusterIdDest, "
								+ "clusterTypeDest, "
								+ "entityDest, "
								+ "isCompressedDest "
								+ "FROM cube WHERE uniqueName LIKE ?";
		
		RepoCubeRecordList repoCubeRecordList = new RepoCubeRecordList();
		
		try (Connection conn = DriverManager.getConnection(DB_URL_DISK, USER, PASS); 
				PreparedStatement preparedStatement = conn.prepareStatement(sqlString))	{
			
            preparedStatement.setString(1, "%" + uniqueName + "%");
            
			ResultSet rs = preparedStatement.executeQuery();
            while ( rs.next() ) {
            	RepoCubeRecord r = new RepoCubeRecord(	rs.getInt("cubeId"),
									            		rs.getString("uniqueName"), 
									            		rs.getString("path"),
									            		rs.getString("comment"),
									            		rs.getLong("clusterIdSource"),
									            		rs.getString("clusterTypeSource"),
									            		rs.getString("isCompressedSource"),
									            		rs.getLong("sqlIdSource"),
									            		rs.getLong("cubeIdSource"),
									            		rs.getLong("clusterIdDest"),
									            		rs.getString("clusterTypeDest"),
									            		rs.getString("entityDest"),
									            		rs.getString("isCompressedDest")
			            			                  );
            	
            	repoCubeRecordList.addRepoCubeRecord(r);
            }
            rs.close();
            return repoCubeRecordList;
		} catch (SQLException e)	{
			throw new Exception(AppLogger.logDb(e, Thread.currentThread().getStackTrace()[1]));
		} catch (Exception e) {
			throw new Exception(AppLogger.logException(e, Thread.currentThread().getStackTrace()[1], AppLogger.db));
		}
	}
	
	
	public 
	RepoCubeRecord 
	getRepoCubeRecord(final long cubeId) throws Exception {
		Class.forName(JDBC_DRIVER);
		String sqlString = "SELECT cubeId, "
								+ "uniqueName, "
								+ "path, "
								+ "comment, "
								+ "cubeIdSource, "
								+ "clusterIdSource, "
								+ "clusterTypeSource, "
								+ "isCompressedSource, "
								+ "sqlIdSource, "
								+ "clusterIdDest, "
								+ "clusterTypeDest, "
								+ "entityDest, "
								+ "isCompressedDest "
								+ "FROM cube WHERE cubeId = ?";
		
		RepoCubeRecord r = null;
		
		try (Connection conn = DriverManager.getConnection(DB_URL_DISK, USER, PASS); 
				PreparedStatement preparedStatement = conn.prepareStatement(sqlString))	{
			
            preparedStatement.setLong(1, cubeId);
            
			ResultSet rs = preparedStatement.executeQuery();
			if(rs.next()) {
				r = new RepoCubeRecord(	rs.getInt("cubeId"),
										rs.getString("uniqueName"),
										rs.getString("path"),
										rs.getString("comment"),
										rs.getLong("clusterIdSource"),
										rs.getString("clusterTypeSource"),
										rs.getString("isCompressedSource"),
										rs.getLong("sqlIdSource"),
										rs.getLong("cubeIdSource"),
										rs.getLong("clusterIdDest"),
										rs.getString("clusterTypeDest"),
										rs.getString("entityDest"),
										rs.getString("isCompressedDest")
								);
			}

            rs.close();
            return r;
		} catch (SQLException e)	{
			throw new Exception(AppLogger.logDb(e, Thread.currentThread().getStackTrace()[1]));
		} catch (Exception e) {
			throw new Exception(AppLogger.logException(e, Thread.currentThread().getStackTrace()[1], AppLogger.db));
		}
	}
	
	
	
	public 
	void 
	addCube(final RepoCubeRecord repoCubeRecord) throws Exception {
		Class.forName(JDBC_DRIVER);
		String sqlString = "INSERT INTO cube (uniqueName, "
												+ "path, "
												+ "comment, "
												+ "clusterIdSource, "
												+ "clusterTypeSource, "
												+ "isCompressedSource, "
												+ "sqlIdSource, "
												+ "cubeIdSource, "
												+ "clusterIdDest, "
												+ "clusterTypeDest, "
												+ "entityDest, "
												+ "isCompressedDest "
												+ ") VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
		
		try (Connection conn = DriverManager.getConnection(DB_URL_DISK, USER, PASS); 
				PreparedStatement preparedStatement = conn.prepareStatement(sqlString))	{
			preparedStatement.setString(1, repoCubeRecord.getUniqueName());
			preparedStatement.setString(2, repoCubeRecord.getPath());
			preparedStatement.setString(3, repoCubeRecord.getComment());
			preparedStatement.setLong(4, repoCubeRecord.getClusterIdSource());
			preparedStatement.setString(5, repoCubeRecord.getClusterTypeSource());
			preparedStatement.setString(6, repoCubeRecord.getIsCompressedSource());
			preparedStatement.setLong(7, repoCubeRecord.getSqlIdSource());
			preparedStatement.setLong(8, repoCubeRecord.getCubeIdSource());
			preparedStatement.setLong(9, repoCubeRecord.getClusterIdDest());
			preparedStatement.setString(10, repoCubeRecord.getClusterTypeDest());
			preparedStatement.setString(11, repoCubeRecord.getEntityDest());
			preparedStatement.setString(12, repoCubeRecord.getIsCompressedDest());
			
			preparedStatement.execute();
		} catch (SQLException e)	{
			throw new Exception(AppLogger.logDb(e, Thread.currentThread().getStackTrace()[1]));
		} catch (Exception e) {
			throw new Exception(AppLogger.logException(e, Thread.currentThread().getStackTrace()[1], AppLogger.db));
		}
	}
	
	public 
	void 
	deleteCube(final long cubeId) throws Exception {
		Class.forName(JDBC_DRIVER);
		String sqlString = "DELETE FROM cube WHERE cubeId=?";
		try (Connection conn = DriverManager.getConnection(DB_URL_DISK, USER, PASS); 
				PreparedStatement preparedStatement = conn.prepareStatement(sqlString)) {
			preparedStatement.setLong(1, cubeId);
			preparedStatement.execute();
		} catch (SQLException e)	{
			throw new Exception(AppLogger.logDb(e, Thread.currentThread().getStackTrace()[1]));
		} catch (Exception e) {
			throw new Exception(AppLogger.logException(e, Thread.currentThread().getStackTrace()[1], AppLogger.db));
		}
	}

}

